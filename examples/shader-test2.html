<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - animation - keyframes</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
		<style>
			body {
				background-color: #bfe3dd;
				color: #000;
			}

			a {
				color: #2983ff;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"vertex": "./shader/test1/vertexShader.js",
					"fragment": "./shader/test1/fragmentShader.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import Stats from "three/addons/libs/stats.module.js";

			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

			import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
			import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
			import vertexShader from "vertex";
			import fragmentShader from "fragment";
			let mixer;
			let anis = [];

			const clock = new THREE.Clock();
			const container = document.getElementById("container");

			const stats = new Stats();
			container.appendChild(stats.dom);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			const pmremGenerator = new THREE.PMREMGenerator(renderer);

			const scene = new THREE.Scene();
			// scene.background = new THREE.Color( 0xbfe3dd );
			scene.environment = pmremGenerator.fromScene(
				new RoomEnvironment(renderer),
				0.04
			).texture;
			// scene.fog = new THREE.Fog( 0x88ccee, 0, 50 );

			const camera = new THREE.PerspectiveCamera(
				40,
				window.innerWidth / window.innerHeight,
				1,
				1000
			);
			camera.position.set(50, 20, 80);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 0.5, 0);
			controls.update();
			controls.enablePan = false;
			controls.enableDamping = true;

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath("jsm/libs/draco/gltf/");

			const loader = new GLTFLoader();
			loader.setDRACOLoader(dracoLoader);
			loader.load(
				"models/gltf/LittlestTokyo.glb",
				function (gltf) {
					const model = gltf.scene;
					model.position.set(1, 1, 0);
					model.scale.set(0.01, 0.01, 0.01);
					// scene.add( model );

					mixer = new THREE.AnimationMixer(model);
					mixer.clipAction(gltf.animations[0]).play();

					animate();
				},
				undefined,
				function (e) {
					console.error(e);
				}
			);
			window.onresize = function () {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			};

			function animate() {
				requestAnimationFrame(animate);

				const delta = clock.getDelta();
				mixer.update(delta);

				controls.update();

				stats.update();

				renderer.render(scene, camera);
			}
			createFont("🌈", new THREE.Vector3(-2, 0, 0)); 
			createFont("👏", new THREE.Vector3(0, 0, 0));
			createFont("💩", new THREE.Vector3(2, 0, 0));
			createFont("🎉", new THREE.Vector3(4, 0, 0));
			createFont("T", new THREE.Vector3(0, -2, 0));
			createFont("H", new THREE.Vector3(2, -2, 0));
			createFont("R", new THREE.Vector3(4, -2, 0));
			createFont("E", new THREE.Vector3(6, -2, 0));
			createFont("E", new THREE.Vector3(8, -2, 0)); 
			function createTexture(font) {
				let canvas = document.createElement("canvas");
				let ctx = canvas.getContext("2d");
				let texture = new THREE.Texture(canvas);
				const accuracy = 1;
				canvas.width = 256 * accuracy;
				canvas.height = 256 * accuracy;
				ctx.fillStyle = "#000";
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.shadowBlur = 5 * accuracy;
				ctx.shadowColor = "#ffffff";
				//绘制文字
				ctx.font = `${200 * accuracy}px Georgia`;
				ctx.textAlign = "center";
				ctx.fillStyle = "#ffffff";
				ctx.fillText(font, 110 * accuracy, 190 * accuracy);
				texture.needsUpdate = true;
				texture.colorSpace = THREE.SRGBColorSpace;
				return texture;
			}

			function createFont(font, position) {
				let texture = createTexture(font);
				let mesh;
				const material = new THREE.MeshStandardMaterial({
					map: texture,
					// alphaMap: texture,
					// transparent: true,
					displacementMap: texture,
					displacementScale: 0.5,
					side: THREE.DoubleSide,
				});
				material.onBeforeCompile = (shader) => {
					console.log(shader.fragmentShader);
					shader.fragmentShader = shader.fragmentShader.replace(
						"#include <dithering_fragment>",
						`
						#include <dithering_fragment>
						float j = 0.2;
						if(gl_FragColor.r < j && gl_FragColor.g < j && gl_FragColor.b < j){
							discard;
						}
						`
					);

				};
				mesh = new THREE.Mesh(
					new THREE.PlaneGeometry(2, 2, 80, 80),
					material
				);
				mesh.position.copy(position);
				scene.add(mesh)
			}
		</script>
	</body>
</html>
