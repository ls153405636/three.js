<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - animation - keyframes</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
		<style>
			body {
				background-color: #bfe3dd;
				color: #000;
			}

			a {
				color: #2983ff;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"vertex": "./shader/test1/vertexShader.js",
					"fragment": "./shader/test1/fragmentShader.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import Stats from "three/addons/libs/stats.module.js";

			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

			import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
			import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
			import vertexShader from "vertex";
			import fragmentShader from "fragment";
			let mixer;
			let anis = []

			const clock = new THREE.Clock();
			const container = document.getElementById("container");

			const stats = new Stats();
			container.appendChild(stats.dom);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			const pmremGenerator = new THREE.PMREMGenerator(renderer);

			const scene = new THREE.Scene();
			// scene.background = new THREE.Color( 0xbfe3dd );
			scene.environment = pmremGenerator.fromScene(
				new RoomEnvironment(renderer),
				0.04
			).texture;
			// scene.fog = new THREE.Fog( 0x88ccee, 0, 50 );

			const camera = new THREE.PerspectiveCamera(
				40,
				window.innerWidth / window.innerHeight,
				1,
				1000
			);
			camera.position.set(50, 20, 80);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 0.5, 0);
			controls.update();
			controls.enablePan = false;
			controls.enableDamping = true;

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath("jsm/libs/draco/gltf/");

			const loader = new GLTFLoader();
			loader.setDRACOLoader(dracoLoader);
			loader.load(
				"models/gltf/LittlestTokyo.glb",
				function (gltf) {
					const model = gltf.scene;
					model.position.set(1, 1, 0);
					model.scale.set(0.01, 0.01, 0.01);
					// scene.add( model );

					mixer = new THREE.AnimationMixer(model);
					mixer.clipAction(gltf.animations[0]).play();

					animate();
				},
				undefined,
				function (e) {
					console.error(e);
				}
			);
			window.onresize = function () {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			};
			let plane
			let boxs = [];
			createBoxs()
			createPlane()
			function createPlane () {
				let planeMat = new THREE.ShaderMaterial({
					transparent: true,
					side: THREE.DoubleSide,
					uniforms: {
						color1: {value: new THREE.Color('#e2fb00')},
						color2: {value: new THREE.Color('#041cf2')},
						scale: {value: 0},
					},
					vertexShader: /* glsl */ `
						varying vec2 vUv;
						void main() {
							vUv = uv;
							gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
						}
					`,
					fragmentShader:  /* glsl */ `
						varying vec2 vUv;
						uniform vec3 color1;
						uniform vec3 color2;
						uniform float scale;
						void main() {
							float dis = distance(vUv, vec2(0.5,0.5));
							float opacity = smoothstep(0.4 * scale, 0.5 * scale, dis);
							opacity *= step(dis, 0.5* scale);
							opacity -= (scale - 0.8) * 5.0 * step(0.8, scale);
							vec3 disColor = color1 - color2;
							vec3 color = color2 + disColor * scale;
							gl_FragColor = vec4(color, opacity);
						}
					`
				})
				plane = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), planeMat);
				plane.rotation.x = -Math.PI / 2;
				scene.add(plane);

				const forceColor = new THREE.Color('#51f')
				boxs.forEach((box) => {
					box.material.uniforms.forceColor = {value: forceColor}
				})
				function ani() {
					requestAnimationFrame(ani);
					const delta = clock.getDelta();
					planeMat.uniforms.scale.value += 0.01
					planeMat.uniforms.scale.value %= 1
					// planeMat.uniforms.scale.value = Math.abs(Math.sin(performance.now()/ 2000) )

					const scale = planeMat.uniforms.scale.value
					const far = scale * 50
					const near = (scale-0.1) * 50
					const decay = scale > 0.8 ? 1 - (scale - 0.8) * 5 : 1

					boxs.forEach((box) => {
						const distance = box.position.distanceTo(plane.position)
						box.material.uniforms.decay = {value: decay}
						if (distance > near && distance < far) {
							const p = (far - distance) / (far-near)
							box.material.uniforms.forceColorProgress = {value: p}
						}else {
							box.material.uniforms.forceColorProgress = {value: -1}
						}
					})

				}
				ani();
			}
			function createBoxs() {
				let boxMat = new THREE.ShaderMaterial({
					uniforms: {
						tColor: { value: new THREE.Color("#fff") },
						tColor2: { value: new THREE.Color("#ff0") },
						bColor: { value: new THREE.Color("#000") },
						uTime: { value: 0 },
						uSpeed: { value: 0 },
					},
					vertexShader,
					fragmentShader,
					tranparent: true,
					side: THREE.DoubleSide,
					vertexColors: true,
				});
				let geo = new THREE.BoxGeometry(
					1,
					1,
					1,
					1,
					10,
					1
				);
				const { random } = Math;
				for (let i = 0; i < 5000; i++) {
					let itemMat = boxMat.clone();
					itemMat.uniforms.tColor.value.r = random();
					itemMat.uniforms.tColor2.value.r = random();
					itemMat.uniforms.uSpeed.value = (0.5 - random()) * 4;
					itemMat.uniforms.uHeight = { value: 1 };
					let box = new THREE.Mesh(geo, itemMat);
					boxs.push(box);
					box.scale.set(random() * 2, random() * 10, random() * 2)
					box.position.x = (0.5 - random()) * 100;
					box.position.z = (0.5 - random()) * 100;
					box.position.y += box.scale.y / 2;
					if (box.position.distanceTo(new THREE.Vector3(0,0,0)) <= 50) {
						scene.add(box);
					}
				}

				const ani = (fn) => {
					requestAnimationFrame(ani);
					const delta = clock.getDelta();
					boxs.forEach((box) => {
						box.material.uniforms.uTime.value += 0.01;
					})
				}
				ani();
			}

			function animate() {
				requestAnimationFrame(animate);

				const delta = clock.getDelta();
				mixer.update(delta);

				controls.update();

				stats.update();

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
