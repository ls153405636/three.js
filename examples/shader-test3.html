<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - animation - keyframes</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
		<style>
			body {
				background-color: #bfe3dd;
				color: #000;
			}

			a {
				color: #2983ff;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"vertex": "./shader/test1/vertexShader.js",
					"fragment": "./shader/test1/fragmentShader.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import Stats from "three/addons/libs/stats.module.js";

			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

			import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
			import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let mixer;
			let anis = [];
			let gui = new GUI()

			const clock = new THREE.Clock();
			const container = document.getElementById("container");

			const stats = new Stats();
			container.appendChild(stats.dom);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			const pmremGenerator = new THREE.PMREMGenerator(renderer);

			const scene = new THREE.Scene();
			// scene.background = new THREE.Color( 0xbfe3dd );
			scene.environment = pmremGenerator.fromScene(
				new RoomEnvironment(renderer),
				0.04
			).texture;
			// scene.fog = new THREE.Fog( 0x88ccee, 0, 50 );

			const camera = new THREE.PerspectiveCamera(
				40,
				window.innerWidth / window.innerHeight,
				1,
				1000
			);
			camera.position.set(50, 20, 80);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 0.5, 0);
			controls.update();
			controls.enablePan = false;
			controls.enableDamping = true;

			let geometry, material, sphere
			createSphere()
			animate();
			gui.add(material.uniforms.uThickness, 'value', 0,10)
			gui.addColor(material.uniforms.uColor, 'value')

			function createSphere() {
				let box = new THREE.Mesh(new THREE.BoxGeometry(3,3,3), new THREE.MeshBasicMaterial({color: 0xffffff}))
				scene.add(box)
				console.log(box);
				let texture = new THREE.TextureLoader().load('./textures/water.jpg')
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping
				geometry = new THREE.SphereGeometry( 15, 200,200 ); 
				material = new THREE.ShaderMaterial( { 
					uniforms: {
						uThickness: {value: 1},
						uTime: {value: 0},
						uTexture: {value: texture},
						uColor: {value: new THREE.Color('#fff')},
					},

					transparent: true,
					blending: THREE.AdditiveBlending,
					vertexShader: /*glsl*/`
						varying vec2 vUv;
						varying float vIntensity;
						uniform float uThickness;
						uniform float uTime;
						void main(){
							vUv = uv;
							vec4 worldPosition = modelMatrix * vec4(position, 1.0);
							vec3 worldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
							vec3 dirToNormal = normalize(cameraPosition - worldNormal.xyz);
							vIntensity = 1.0-dot(worldNormal, dirToNormal);
							vIntensity = pow(vIntensity, uThickness);
							gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
						}
					`,
					fragmentShader: /*glsl*/`
						varying vec2 vUv;
						varying float vIntensity;
						uniform sampler2D uTexture;
						uniform vec3 uColor;
						uniform float uTime;


						void main(){
							vec2 nUv = vUv;
							nUv.y -= (uTime) * 0.3;
							nUv.x += sin(uTime) * 0.3;
							vec4 noiseTexture = texture2D(uTexture, nUv);
							vec3 finalColor = noiseTexture.rgb * uColor;
							gl_FragColor = vec4(finalColor * vIntensity * 10.0, 1.0);
						}
					`
				} ); 
				sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
				scene.add(sphere)
			}

			window.onresize = function () {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			};

			function animate() {
				requestAnimationFrame(animate);

				const delta = clock.getDelta();
				material.uniforms.uTime.value += delta

				controls.update();

				stats.update();

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
